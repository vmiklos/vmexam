#!/usr/bin/env python3
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
# This parses the output of 'iwyu_tool.py -p . /path/to/test.cxx 2>&1',
# focusing on just removing not needed includes and providing a relatively
# conservative output by filtering out a number of LibreOffice-specific false
# positives.
#
# It assumes you have a 'compile_commands.json' around (similar to clang-tidy),
# you can generate one with 'make vim-ide-integration'.
#

import os
import re
import sys
import yaml


def unwrapInclude(include):
    # Drop <> or "" around the include.
    return include[1:-1]


def getFwdDecl(include, keyword):
    match = re.match("(.*).hpp", include)
    tokens = match.group(1).split("/")
    start = []
    end = []
    forwardDecl = None
    for i in range(len(tokens)):
        if i == len(tokens) - 1:
            forwardDecl = "%s%s %s;%s" % ("".join(start), keyword, tokens[-1], "".join(end))
        else:
            start.append("namespace %s { " % tokens[i])
            end.append(" }")
    return forwardDecl


def ignoreRemoval(include, toAdd, absFileName):
    # global rules

    # Avoid replacing .hpp with .hdl in the com::sun::star namespace.
    if include.startswith("com/sun/star") and include.endswith(".hpp"):
        hdl = include.replace(".hpp", ".hdl")
        if hdl in toAdd:
            return True

        # Forward declaration case.
        if getFwdDecl(include, "class") in toAdd or getFwdDecl(include, "struct") in toAdd:
            return True

    # rtl::Reference fwd decl case.
    if include == "rtl/ref.hxx" and "namespace rtl { template <class reference_type> class Reference; }" in toAdd:
        return True

    # uno::Sequence fwd decl case.
    if include == "com/sun/star/uno/Sequence.hxx" and "namespace com { namespace sun { namespace star { namespace uno { template <class E> class __attribute__((type_visibility(\"default\"))) __attribute__((warn_unused)) Sequence; } } } }" in toAdd:
        return True

    # uno::Any fwd decl case.
    if include == "com/sun/star/uno/Any.hxx" and "namespace com { namespace sun { namespace star { namespace uno { class Any; } } } }" in toAdd:
        return True

    # Avoid debug STL.
    debugStl = {
        "array": "debug/array",
        "deque": "debug/deque",
        "list": "debug/list",
        "map": "debug/map.h",
        "set": "debug/set.h",
        "unordered_map": "debug/unordered_map",
        "unordered_set": "debug/unordered_set",
        "vector": "debug/vector",
    }
    for k, v in debugStl.items():
        if include == k and v in toAdd:
            return True

    # Follow boost documentation.
    if include == "boost/optional.hpp" and "boost/optional/optional.hpp" in toAdd:
        return True
    if include == "boost/intrusive_ptr.hpp" and "boost/smart_ptr/intrusive_ptr.hpp" in toAdd:
        return True

    # 3rd-party, non-self-contained headers.
    if include == "libepubgen/libepubgen.h" and "libepubgen/libepubgen-decls.h" in toAdd:
        return True
    if include == "librevenge/librevenge.h" and "librevenge/RVNGPropertyList.h" in toAdd:
        return True

    noRemove = (
        # <https://www.openoffice.org/tools/CodingGuidelines.sxw> insists on not
        # removing this.
        "sal/config.h",
        # Works around a build breakage specific to the broken Android
        # toolchain.
        "android/compatibility.hxx",
    )
    if include in noRemove:
        return True

    # Ignore when <foo> is to be replaced with "foo".
    if include in toAdd:
        return True

    fileName = os.path.relpath(absFileName, os.getcwd())

    # yaml rules

    moduleName = fileName.split("/")[0]

    rulePath = os.path.join(os.path.dirname(os.path.abspath(__file__)), "IwyuFilter_" + moduleName + ".yaml")
    moduleRules = {}
    if os.path.exists(rulePath):
        moduleRules = yaml.load(open(rulePath))
    if fileName in moduleRules.keys():
        if include in moduleRules[fileName]:
            return True

    return False


def processIWYUOutput(iwyuOutput):
    inAdd = False
    toAdd = []
    inRemove = False
    toRemove = []
    currentFileName = None
    for line in iwyuOutput:
        line = line.strip()

        if len(line) == 0:
            if inRemove:
                inRemove = False
                continue
            if inAdd:
                inAdd = False
                continue

        match = re.match("(.*) should add these lines:$", line)
        if match:
            currrentFileName = match.group(1)
            inAdd = True
            continue

        match = re.match("(.*) should remove these lines:$", line)
        if match:
            currentFileName = match.group(1)
            inRemove = True
            continue

        if inAdd:
            match = re.match('#include ([^ ]+)', line)
            if match:
                include = unwrapInclude(match.group(1))
                toAdd.append(include)
            else:
                # Forward declaration.
                toAdd.append(line)

        if inRemove:
            match = re.match("- #include (.*)  // lines (.*)-.*", line)
            if match:
                include = unwrapInclude(match.group(1))
                lineno = match.group(2)
                if not ignoreRemoval(include, toAdd, currentFileName):
                    toRemove.append("%s:%s: %s" % (currentFileName, lineno, include))
                continue

    for remove in toRemove:
        print("%s: remove not needed include" % remove)
    return min(len(toRemove), 100)

if __name__ == '__main__':
    sys.exit(processIWYUOutput(sys.stdin))

# vim:set shiftwidth=4 softtabstop=4 expandtab:
