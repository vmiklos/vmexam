#!/usr/bin/env python3
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
# This parses the output of 'iwyu_tool.py -p . /path/to/test.cxx 2>&1',
# focusing on just removing not needed includes and providing a relatively
# conservative output by filtering out a number of LibreOffice-specific false
# positives.
#
# It assumes you have a 'compile_commands.json' around (similar to clang-tidy),
# you can generate one with 'make vim-ide-integration'.
#

import re
import sys


def unwrapInclude(include):
    # Drop <> or "" around the include.
    return include[1:-1]


def getFwdDecl(include, keyword):
    match = re.match("(.*).hpp", include)
    tokens = match.group(1).split("/")
    start = []
    end = []
    forwardDecl = None
    for i in range(len(tokens)):
        if i == len(tokens) - 1:
            forwardDecl = "%s%s %s;%s" % ("".join(start), keyword, tokens[-1], "".join(end))
        else:
            start.append("namespace %s { " % tokens[i])
            end.append(" }")
    return forwardDecl


def ignoreRemoval(include, toAdd, currentFileName):
    # Avoid replacing .hpp with .hdl in the com::sun::star namespace.
    if include.startswith("com/sun/star") and include.endswith(".hpp"):
        hdl = include.replace(".hpp", ".hdl")
        if hdl in toAdd:
            return True

        # Forward declaration case.
        if getFwdDecl(include, "class") in toAdd or getFwdDecl(include, "struct") in toAdd:
            return True

    # rtl::Reference fwd decl case.
    if include == "rtl/ref.hxx" and "namespace rtl { template <class reference_type> class Reference; }" in toAdd:
        return True

    # uno::Sequence fwd decl case.
    if include == "com/sun/star/uno/Sequence.hxx" and "namespace com { namespace sun { namespace star { namespace uno { template <class E> class __attribute__((type_visibility(\"default\"))) __attribute__((warn_unused)) Sequence; } } } }" in toAdd:
        return True

    # uno::Any fwd decl case.
    if include == "com/sun/star/uno/Any.hxx" and "namespace com { namespace sun { namespace star { namespace uno { class Any; } } } }" in toAdd:
        return True

    # Avoid debug STL.
    debugStl = {
        "vector": "debug/vector",
        "set": "debug/set.h",
        "map": "debug/map.h",
        "unordered_map": "debug/unordered_map"
    }
    for k, v in debugStl.items():
        if include == k and v in toAdd:
            return True

    # Follow boost documentation.
    if include == "boost/optional.hpp" and "boost/optional/optional.hpp" in toAdd:
        return True
    if include == "boost/intrusive_ptr.hpp" and "boost/smart_ptr/intrusive_ptr.hpp" in toAdd:
        return True

    # 3rd-party, non-self-contained headers.
    if include == "libepubgen/libepubgen.h" and "libepubgen/libepubgen-decls.h" in toAdd:
        return True
    if include == "librevenge/librevenge.h" and "librevenge/RVNGPropertyList.h" in toAdd:
        return True

    noRemove = (
        # <https://www.openoffice.org/tools/CodingGuidelines.sxw> insists on not
        # removing this.
        "sal/config.h",
        # Works around a build breakage specific to the broken Android
        # toolchain.
        "android/compatibility.hxx",
    )
    if include in noRemove:
        return True

    # Ignore when <foo> is to be replaced with "foo".
    if include in toAdd:
        return True

    # IWYU assumes std::stack<IncompleteType> in a header is OK, but that's not
    # the case for all of LO's supported platforms.
    # See <https://github.com/include-what-you-use/include-what-you-use/issues/175>.
    if currentFileName.endswith("writerfilter/source/rtftok/rtfsdrimport.hxx") and include.endswith("dmapper/GraphicZOrderHelper.hxx"):
        return True
    if include == "list":
        fileNames = [
            "sw/inc/PostItMgr.hxx",
            "sw/inc/finalthreadmanager.hxx",
            "sw/inc/frmfmt.hxx",
        ]
        for fileName in fileNames:
            if currentFileName.endswith(fileName):
                return True
    if include == "vector":
        fileNames = [
            "sw/inc/extinput.hxx",
            "sw/inc/fmtmeta.hxx",
            "sw/inc/istyleaccess.hxx",
        ]
        for fileName in fileNames:
            if currentFileName.endswith(fileName):
                return True
    if currentFileName.endswith("sw/inc/acmplwrd.hxx") and include == "deque":
        return True
    if (currentFileName.endswith("sw/inc/accmap.hxx") or currentFileName.endswith("sw/inc/dcontact.hxx")) and include == "list":
        return True
    if currentFileName.endswith("sw/inc/bparr.hxx") and include == "array":
        return True
    if currentFileName.endswith("sw/inc/docary.hxx") and include in ("fldbas.hxx", "numrule.hxx", "tox.hxx"):
        # Complete type is needed here:
        # fldbas.hxx brings in SwTOXType, which is needed by SwTOXTypes, as SwVectorModifyBase's dtor wants to delete it
        # numrule.hxx brings in SwNumRule, which is needed by SwNumRuleTable, as SwVectorModifyBase's dtor wants to delete it
        # tox.hxx brings in SwTOXType, which is needed by SwTOXTypes, as SwVectorModifyBase's dtor wants to delete it
        return True
    if currentFileName.endswith("sw/inc/docfac.hxx") and include == "doc.hxx":
        # Complete type is needed by rtl::Reference<SwDoc>.
        return True
    if include == "o3tl/typed_flags_set.hxx":
        # Inheritance from o3tl::is_typed_flags<>, include is needed.
        fileNames = [
            "sw/inc/accmap.hxx",
            "sw/inc/crsrsh.hxx",
            "sw/inc/cshtyp.hxx",
            "sw/inc/fesh.hxx",
            "sw/inc/modcfg.hxx",
            "sw/inc/ndtyp.hxx",
        ]
        for fileName in fileNames:
            if currentFileName.endswith(fileName):
                return True
    if include == "o3tl/deleter.hxx":
        # o3tl::default_delete<> usage, include is needed.
        fileNames = [
            "sw/inc/doc.hxx",
            "sw/inc/list.hxx",
        ]
        for fileName in fileNames:
            if currentFileName.endswith(fileName):
                return True
    if currentFileName.endswith("sw/inc/IDocumentLinksAdministration.hxx") and include.endswith("sal/types.h"):
        # css namespace alias is declared there.
        return True
    if currentFileName.endswith("sw/inc/pagedesc.hxx") and include == "boost/multi_index/identity.hpp":
        # boost::multi_index::identity<> usage.
        return True
    if currentFileName.endswith("sw/inc/rdfhelper.hxx") and include == "com/sun/star/uno/Reference.h":
        # uno::Reference<> usage.
        return True
    if currentFileName.endswith("sw/inc/ring.hxx") and include == "utility":
        # std::wap<> usage.
        return True

    return False


def processIWYUOutput(iwyuOutput):
    inAdd = False
    toAdd = []
    inRemove = False
    toRemove = []
    currentFileName = None
    for line in iwyuOutput:
        line = line.strip()

        if len(line) == 0:
            if inRemove:
                inRemove = False
                continue
            if inAdd:
                inAdd = False
                continue

        match = re.match("(.*) should add these lines:$", line)
        if match:
            currrentFileName = match.group(1)
            inAdd = True
            continue

        match = re.match("(.*) should remove these lines:$", line)
        if match:
            currentFileName = match.group(1)
            inRemove = True
            continue

        if inAdd:
            match = re.match('#include ([^ ]+)', line)
            if match:
                include = unwrapInclude(match.group(1))
                toAdd.append(include)
            else:
                # Forward declaration.
                toAdd.append(line)

        if inRemove:
            match = re.match("- #include (.*)  // lines (.*)-.*", line)
            if match:
                include = unwrapInclude(match.group(1))
                lineno = match.group(2)
                if not ignoreRemoval(include, toAdd, currentFileName):
                    toRemove.append("%s:%s: %s" % (currentFileName, lineno, include))
                continue

    for remove in toRemove:
        print("%s: remove not needed include" % remove)
    return min(len(toRemove), 100)

if __name__ == '__main__':
    sys.exit(processIWYUOutput(sys.stdin))

# vim:set shiftwidth=4 softtabstop=4 expandtab:
