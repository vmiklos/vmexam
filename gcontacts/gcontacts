#!/usr/bin/env python
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#

from __future__ import print_function
from xml.dom import minidom
import gdata
import gdata.contacts.client
import getopt
import oauth2client
import oauth2client.file
import os
import sys


class Match(object):
    def __init__(self, name, email):
        self.name = name
        self.email = email

    def __eq__(self, other):
        # Intentionally ignore name here.
        return self.email == other.email

    def __hash__(self):
        # Intentionally ignore name here.
        return hash(self.email)


class GContacts(object):
    def __init__(self):
        configPath = os.path.expanduser("~/.gcontacts")
        self.clientSecretsPath = os.path.join(configPath, "client_secrets.json")
        self.contactsXmlPath = os.path.join(configPath, "contacts.xml")
        self.contactsLdapXmlPath = os.path.join(configPath, "contacts-ldap.xml")
        self.oauth2ClientJsonPath = os.path.join(configPath, "oauth2client.json")

    def updateCredentials(self, interactive):
        if not interactive:
            print("Please run gcontacts interactively to update credentials.")
            sys.exit(1)
        auth_uri = self.flow.step1_get_authorize_url()
        print("URL: " + auth_uri)
        auth_code = raw_input("Code: ")
        credential = self.flow.step2_exchange(auth_code)
        self.storage.locked_put(credential)
        self.updateToken()

    def updateToken(self):
        self.oauth2Token = gdata.gauth.OAuth2Token(self.flow.client_id, self.flow.client_secret, self.flow.scope, self.flow.user_agent, self.flow.auth_uri, self.flow.token_uri,
                                                   self.storage.get().access_token, self.storage.get().refresh_token, self.flow.revoke_uri)

    def select(self, xmlPath, args):
        def getName(entryNode):
            nameNodes = [i for i in entryNode.childNodes if i.localName == "name"]
            for nameNode in nameNodes:
                fullNameNodes = [i for i in nameNode.childNodes if i.localName == "fullName"]
                for fullNameNode in fullNameNodes:
                    return fullNameNode.childNodes[0].wholeText

        def getEmails(entryNode):
            emails = []
            emailNodes = [i for i in entryNode.childNodes if i.localName == "email"]
            for emailNode in emailNodes:
                if emailNode.hasAttribute("address"):
                    emails.append(emailNode.getAttribute("address"))
            return emails

        def match(pattern, name, email):
            if email:
                pattern = pattern.lower()
                name = name.lower()
                email = email.lower()

                if pattern in name:
                    return True
                elif pattern in email:
                    return True

            return False

        patternString = args[0].decode('utf-8')
        if not os.path.exists(xmlPath):
            return
        contacts = minidom.parse(xmlPath)
        feedNode = [i for i in contacts.childNodes if i.localName == "feed"][0]
        contactNodes = [i for i in feedNode.childNodes if i.localName == "entry"]
        matches = []
        for contactNode in contactNodes:
            name = getName(contactNode)
            emails = getEmails(contactNode)
            for email in emails:
                if match(patternString, name, email):
                    matches.append(Match(name, email))
        matches = sorted(set(matches))
        for i in matches:
            lineString = '"%s" <%s>' % (i.name, i.email)
            print(lineString.encode('utf-8'))

    def update(self, interactive):
        scopeList = ["https://www.google.com/m8/feeds", "https://www.googleapis.com/auth/contacts"]
        try:
            self.flow = oauth2client.client.flow_from_clientsecrets(self.clientSecretsPath, scopeList, redirect_uri="urn:ietf:wg:oauth:2.0:oob")
        except oauth2client.clientsecrets.InvalidClientSecretsError:
            print("~/.gcontacts/client_secrets.json is missing, get a client ID from <https://console.developers.google.com/project/_/apiui/credential>.")
            sys.exit(1)
        self.flow.user_agent = self.__class__.__name__

        self.storage = oauth2client.file.Storage(self.oauth2ClientJsonPath)
        if self.storage.get() is None or self.storage.get().invalid:
            self.updateCredentials(interactive)

        while True:
            try:
                self.updateToken()
                contactsClient = gdata.contacts.client.ContactsClient(source=self.__class__.__name__)
                contactsClient = self.oauth2Token.authorize(contactsClient)
                contacts = contactsClient.GetContacts()
                break
            except gdata.client.Unauthorized:
                self.updateCredentials(interactive)

        singlePage = False  # For debugging purposes.
        count = 0
        sock = open(self.contactsXmlPath, "w")
        while contacts is not None:
            if count == 0:
                lines = contacts.ToString().split('\n')
                sock.write("""<?xml version="1.0" encoding="UTF-8"?>\n""")
                sock.write(lines[0] + "\n")
            print("Downloading feed #" + str(count) + "...")
            count += 1
            for contact in contacts.entry:
                if contact.name:
                    sock.write(contact.ToString() + "\n")
            nextLink = contacts.GetNextLink()
            if nextLink and not singlePage:
                contacts = contactsClient.GetContacts(uri=nextLink.href)
            else:
                contacts = None
            if contacts is None:
                sock.write("""</ns0:feed>\n""")
        sock.close()


def main(argv):

    def usage():
        print("""Usage:
gcontacts [ -u | --update ]
gcontacts <pattern>""")
        sys.exit(1)

    try:
        opts, dummy = getopt.getopt(argv, "np:tuq", ["non-interactive", "profile=", "require-title", "update", "quiet"])
    except getopt.GetoptError:
        usage()
    update = False
    interactive = True
    optIndex = 0
    for opt, dummy in opts:
        if opt in ("-u", "--update"):
            update = True
        elif opt in ("-t", "--require-title"):
            pass
        elif opt in ("-q", "--quiet"):
            pass
        elif opt in ("-p", "--profile"):
            pass
        elif opt in ("-n", "--non-interactive"):
            interactive = False
        optIndex += 1
    pattern = argv[optIndex:]

    contacts = GContacts()
    if update:
        contacts.update(interactive)
    else:
        if not len(pattern):
            usage()
        contacts.select(contacts.contactsXmlPath, argv[optIndex:])
        contacts.select(contacts.contactsLdapXmlPath, argv[optIndex:])


if __name__ == "__main__":
    main(sys.argv[1:])

# vim:set shiftwidth=4 softtabstop=4 expandtab:
