= MI első házifeladat, Vajna Miklós <vmiklos@vmiklos.hu>, AYU9RZ, 2008-11-25

== Felépítés

A program forráskódja két file-ban helyezkedik el, a Main.java egyetlen statikus belépési pontot tartalmaz, a feladat maradék része a Hazi.java file-ban található meg.

Ez utóbbi nem csak magát a Hazi osztályt tartalmazza hanem egy beágyazott osztályt is. Ennek az a feladata, hogy az egyes csomópontokhoz rendelt számokat és neveket összekapcsolja, lévén az egyes városokhoz nyilván akarjuk majd tartani a `(gx)` és `h(x)` értéküket is.

Ezen kívül a feladat két fontos modulja a Hazi osztály konstruktora, itt történik meg a bemeneti file értelmezése, valamint az `aStar()` függvény, amely a tényleges útkeresést és a kimeneti file megírását hivatott elvégezni.

== Funkcionalitás

A bemeneti file értelmezése egy egyszerű állapotgéppel történik: megnézzük a sorok elejét, valamint a `hn` és `gn` esetén eltároljuk, hogy hol vagyunk, így a következő sorokban tudni fogjuk, hogy az adott érték melyik halmazhoz szolgáltat adatot.

A kezdő várost és a célt külön tároljuk.

A hn értékeket egy egyszerű asszociatív tömbben (HashMap) tároljuk, a városok közötti távolságokat pedig egy hasonló adatszerkezetben, aminél viszont két Stringet kell megadni ahhoz, hogy számot kapjunk.

A Node osztály konstruktora automatikusan számolja az `f(x)` értékét a `g(x)` és a `h(x)` értékéből. Ezen kívül a Comparable interfész használatával a rendezést a Java API használatával meg tudjuk oldani.

Tekintve, hogy majd az openlist ill. closedlist esetén Node-ok listáiban akarunk keresni név szerint, erre szolgál két függvény: a nameInList() megnézi, hogy egy adott nevű Node szerepel-e a listában, a nodeFromList() pedig vissza is adja.

Ahogy haladunk előre az úton, mindig eltároljuk, hogy egy adott pontba honnan jutottunk. Mikor elérkezünk a célhoz, ebből a cameFrom tömbből építünk a reconstructPath() függvénnyel egy Listát, eldobva a végső megoldás szempontjából érdektelen információkat.

Ami maradt, az már csak maga az aStar() függvény.

Az előadáson ismertetett elképzelésnek megfelelően a következőképp működik:

A nyílt lista tartalmazza a kifejtendő csomópontokat, ez eredetileg csak a startot tartalmazza. A zárd lista pedig a már kifejtetteket, ez kezdetben üres.

Addig keresünk, amíg van kifejtendő csomópont. Ha van, akkor vesszük a nyílt lista legkisebb `f(x)` értékkel rendelkező Node-ját. Megnézzük, hogy ez a cél-e, ha igen akkor készen vagyunk. Ha nem, akkor végigiterálunk a gyerekein. Ha a gyerek már az openlistben van, akkor megnézzük, hogy az adott Node-ból olcsóbb-e eljutni mint ahogy idáig tettük és eszerint frissítjük a a gyerek cameFrom tömbbeli értékét. Ha nincs benne az openlistben akkor pedig hozzáadjuk.

== Algoritmikus megfontolások

Mivel a városok neveit gyakran kapcsoljuk össze az f(x), g(x) és h(x) értékekkel, ezért ehhez külön adatszerkezetet hoztam létre. Ezt leszámítva elegendőnek találtam a Java API beépített HashMap és LinkedList adatszerkezeteit használni. Az egyetlen nemtriviális algoritmus az maga az A*, viszont ennek elvi kérdéseit részletesen tárgyaltuk előadáson.

== Futási eredmények értelmezése

A programot a példaként kiadott bemeneti és kimeneti file-okkal teszteltem első körben, tehát elvártam, hogy ugyanazt a kimenetet adja, ami a példa kimenet. Mikor ez megvolt, akkor a saját bemenetemmel is teszteltem, az első néhány lépés megfelelőnek ígérkezett, de természetesen nem számoltam végig kézzel, hogy ellenőrizzem.

== Egyéb technikai megfontolások

Tekintve, hogy itt egy kis programról van szó, nem találtam indokoltnak, hogy az egyes osztályok adattagjai ne legyenek publikusak, így tehát - ami egyebként oly annyira megszokott - itt nincsenek külön metódusok az egyes adattagok lekérdezésére és beállítására.

Az egyes megjegyzések szintén nem követik a JavaDoc előírásait, mivel a megértést segítendő készültek, nem pedig, hogy API dokumentáció készüljön belőlük.
